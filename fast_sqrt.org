#+OPTIONS: tex:t
#+STARTUP: latexpreview
* 1.
** 迭代算法介绍
   初始的问题是：对于在区间$$ \left[ a, b \right] $$上连续且单调的函数$f(x)$，求方程$$f(x)=0$$的近似解.
   算法描述：
   任意取一个定义域内的值$$x_0$$，开始迭代。
   假设当前的近似解为$$x_i$$，则在点$$(x_i, f(x_i))$$上作$$f(x_i)$$的切线$$l$$，其与$$x$$轴的交点记为$$x_{i+1}$$，那么这是一个更优的近似解。
   切线的代数意义即为函数$$f(x)$$的导数，则可以得到这样的迭代式：
   \begin{center}
   \begin{equation}
   x_{i+1}=x_{i}-\frac{f(x_i)}{f^{'}(x_i)}
   \end{equation}
   \end{center}
   关于其收敛性的证明，请参考[[[[http://staff.science.uva.nl/c.dominik/]]]][这里]
** 计算平方根
   尝试求解$$\sqrt[2]{x}$$的值，其实等价于如下描述：
   设$$f(x)=x^2-n$$，求$$f(x)=0$$的近似解。
   按照前文的迭代式，可以得到：
   \begin{center}
   \begin{equation}
   x_{i+1}=x_{i}-\frac{x_{i}^{2}-n}{2x_i}
   \end{equation}
   \end{center}
   设定一个合适的精度，经过有限次迭代最终能得到一个近似解
* 2. 关于Quake3
** 背景
   在Quake3代码中，有这样一段求解平方根倒数的代码：
   #+BEGIN_SRC C
     float invSqrt(float x)
     {
	     float xhalf = 0.5 * x;
	     int i = *(int*)&x; // get bits for floating value
	     i = 0x5f3759df - (i >> 1); // gives initial guess
	     x = *(float*)&i; // convert bits back to float
	     x = x * (1.5 - xhalf * x * x); // Newton step
	     return x;
     }

   #+END_SRC
   粗看这个代码的逻辑，其实很简单，先取了一个初始值，然后进行了一次迭代。关键在于，仅仅经过一次迭代，
   如何保证结果的精度达到要求？原因在于初始值的选取，本来就已经十分接近解，再进行一次迭代来消除估值本身
   的误差。
** 合理性说明
   先看这一段代码：
   #+BEGIN_SRC C
	     int i = *(int*)&x; // get bits for floating value
	     i = 0x5f3759df - (i >> 1); // gives initial guess
	     x = *(float*)&i; // convert bits back to float
   #+END_SRC   
   先将float转换为整型i，然后对i进行一次移位和减法，再将i转换为float。因此我们先考察浮点数在计算机中的表示。
   现代计算机的浮点数表示，一般遵循IEEE 754标准：其核心是采用以2为底数的科学计数法；
   在10进制下，科学计数法这样表示1043: $$ \pm1.043 \times 10^3$$，而在二进制下，也可以用同样的形式来表示一个浮点数。
   比如二进制写法的$$110.010$$，可以记为$$1.10010 \times 2^2$$。
   要将这样的写法映射到内存中，考察32bit的float。
   最高位d31:符号位，0表示非负，1表示非正。（不直接说正负的原因是:存在$$\pm 0$$的情况）。记为S
   d30-d23:指数域(exponent)，共8位，将其视为无符号整数，则其表示范围为$$0 \thicksim 255$$。
   因此如果用E来表示科学计数法中的指数，那么实际映射到这8位的数为127+E。此外，0和255有特殊值含义，但不影响下面的讨论。
   d22-d0:有效数字域(fraction)，共23位。在标准中规定，整数部分总是1,这样可以避免不必要的精度浪费，因此这23位全部用于表示剩余的小数部分。
   这部分记为F。
   至此，除去0和特殊值，一个一般的浮点数，我们可以这样表示：$$(-1)^S\times(1+F)\times2^E$$。回到我们要考虑的问题，输入为整数的开方计算才有意义，
   因此S位总是0,简化为$$(1+F)\times2^E$$。
   现在我们要求上面这个数的平方根的倒数也就是求$$\frac{1}{\sqrt[2]{(1+F)\times2^E}}$$，我们想要求得的结果也可以用浮点数的计数法，即有效数字在$$[1,2)$$，
   指数域在$$[-128,127]$$。
   分情况讨论：
*** E为奇数
   $$ \frac{1}{\sqrt[2]{(1+F)\times2^E}}=\frac{1}{(1+F)^{\frac{1}{2}}\times2^{\frac{E}{2}}}=(1+F)^{-\frac{1}{2}}\times2^{-\frac{E}{2}}=
   (1+F)^{-\frac{1}{2}}\times2^{-(\frac{E+1}{2}-\frac{1}{2})}=\sqrt[2]{\frac{2}{1+F}}\times2^{-\frac{E+1}{2}}
   $$
*** E为偶数
$$
\frac{1}{\sqrt[2]{(1+F)\times2^E}}=\frac{1}{(1+F)^{\frac{1}{2}}\times2^{\frac{E}{2}}}=\frac{2}{\sqrt[2]{1+F}}\times2^{-\frac{E}{2}-1}
$$
无论E的奇偶性如何，这里都写成了浮点数的计数法的形式。(注意小数部分一定是1.xxx的形式)
观察指数部分，可以发现：被开方数$$f$$的指数域，和$$f$$的平方根的倒数$$f^{'}$$的指数域，几乎是一半的差距，因此考虑直接对$$f$$的指数域进行一次线性变换（移位并加上一个偏移量），
来构造出$$f^{'}$$的指数域。
$$f$$的指数域：$$127+E$$
$$f^{'}$$的指数域：$$127-\frac{E+1}{2}$$或 $$127-\frac{E}{2}-1$$
假设偏移量为$$x$$
E为奇数时：
$$
x-\frac{127+E}{2} = 127 - \frac{E+1}{2}
$$
解得$$
x=190
$$
也就是说，190-原来的指数域/2,恰好是平方根倒数的指数域
E为偶数时：
$$
x-\frac{127+E}{2} = 127 - \frac{E}{2} - 1
$$
解得$$x=189$$
当E为偶数时，注意到指数域为奇数，即最后一位是1,经过右移后，减数的d22位为1,因此只要被减数的d22位为0,并且指数域为190,
那么fraction域作减法的时候，就会因为借位，使得指数域减1恰好变成189.
至此，我们已经可以构造出一个数：其指数域为190,并且它的d22位为0
我们回到代码中的magic number,其值为0x5f3759df，其二进制表示为 0 10111110 01101110101100111011111,发现满足上述条件。

再次注意到，当E为偶数时，做完减法以后，指数域的结果一定是$$127 - \frac{E}{2} - 1$$，但E为奇数时，由于被减数和减数的d22位都为0,如果被减数的d21-d0
比减数小，就会向高位借位，使得指数域相减的结果小1,这里会导致一定误差，但会被后续的迭代缩小。
接下来尝试构造剩余的位。

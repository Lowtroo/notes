#+OPTIONS: tex:t
#+STARTUP: latexpreview
* 1.
** 迭代算法介绍
   初始的问题是：对于在区间$$ \left[ a, b \right] $$上连续且单调的函数$f(x)$，求方程$$f(x)=0$$的近似解.
   算法描述：
   任意取一个定义域内的值$$x_0$$，开始迭代。
   假设当前的近似解为$$x_i$$，则在点$$(x_i, f(x_i))$$上作$$f(x_i)$$的切线$$l$$，其与$$x$$轴的交点记为$$x_{i+1}$$，那么这是一个更优的近似解。
   切线的代数意义即为函数$$f(x)$$的导数，则可以得到这样的迭代式：
   \begin{center}
   \begin{equation}
   x_{i+1}=x_{i}-\frac{f(x_i)}{f^{'}(x_i)}
   \end{equation}
   \end{center}
   关于其收敛性的证明，请参考[[[[http://staff.science.uva.nl/c.dominik/]]]][这里]
** 计算平方根
   尝试求解$$\sqrt[2]{x}$$的值，其实等价于如下描述：
   设$$f(x)=x^2-n$$，求$$f(x)=0$$的近似解。
   按照前文的迭代式，可以得到：
   \begin{center}
   \begin{equation}
   x_{i+1}=x_{i}-\frac{x_{i}^{2}-n}{2x_i}
   \end{equation}
   \end{center}
   设定一个合适的精度，经过有限次迭代最终能得到一个近似解
* 2. 关于Quake3
** 背景
   在Quake3代码中，有这样一段求解平方根倒数的代码：
   #+BEGIN_SRC C
     float invSqrt(float x)
     {
	     float xhalf = 0.5 * x;
	     int i = *(int*)&x; // get bits for floating value
	     i = 0x5f3759df - (i >> 1); // gives initial guess
	     x = *(float*)&i; // convert bits back to float
	     x = x * (1.5 - xhalf * x * x); // Newton step
	     return x;
     }

   #+END_SRC
   粗看这个代码的逻辑，其实很简单，先取了一个初始值，然后进行了一次迭代。关键在于，仅仅经过一次迭代，
   如何保证结果的精度达到要求？原因在于初始值的选取，本来就已经十分接近解，再进行一次迭代来消除估值本身
   的误差。
** 合理性说明
   先看这一段代码：
   #+BEGIN_SRC C
	     int i = *(int*)&x; // get bits for floating value
	     i = 0x5f3759df - (i >> 1); // gives initial guess
	     x = *(float*)&i; // convert bits back to float
   #+END_SRC   
   先将float转换为整型i，然后对i进行一次移位和减法，再将i转换为float。因此我们先考察浮点数在计算机中的表示。
   现代计算机的浮点数表示，一般遵循IEEE 754标准：其核心是采用以2为底数的科学计数法；
   在10进制下，科学计数法这样表示1043: $$ \pm1.043 \times 10^3$$，而在二进制下，也可以用同样的形式来表示一个浮点数。
   比如二进制写法的$$110.010$$，可以记为$$1.10010 \times 2^2$$。
   要将这样的写法映射到内存中，考察32bit的float。
   最高位d31:符号位，0表示非负，1表示非正。（不直接说正负的原因是:存在$$\pm 0$$的情况）。记为S
   d30-d23:指数域(exponent)，共8位，将其视为无符号整数，则其表示范围为$$0 \thicksim 255$$。
   因此如果用E来表示科学计数法中的指数，那么实际映射到这8位的数为127+E。此外，0和255有特殊值含义，但不影响下面的讨论。
   d22-d0:有效数字域(fraction)，共23位。在标准中规定，整数部分总是1,这样可以避免不必要的精度浪费，因此这23位全部用于表示剩余的小数部分。
   这部分记为F。
   至此，除去0和特殊值，一个一般的浮点数，我们可以这样表示：$$(-1)^S\times(1+F)\times2^E$$。回到我们要考虑的问题，输入为整数的开方计算才有意义，
   因此S位总是0,简化为$$(1+F)\times2^E$$。
   现在我们要求上面这个数的平方根的倒数也就是求$$\frac{1}{\sqrt[2]{(1+F)\times2^E}}$$，我们想要求得的结果也可以用浮点数的计数法，即有效数字在$$[1,2)$$，
   指数域在$$[-128,127]$$。
   分情况讨论：
*** E为奇数
   $$ \frac{1}{\sqrt[2]{(1+F)\times2^E}}=\frac{1}{(1+F)^{\frac{1}{2}}\times2^{\frac{E}{2}}}=(1+F)^{-\frac{1}{2}}\times2^{-\frac{E}{2}}=
   (1+F)^{-\frac{1}{2}}\times2^{-(\frac{E+1}{2}-\frac{1}{2})}=\sqrt[2]{\frac{2}{1+F}}\times2^{-\frac{E+1}{2}}
   $$
*** E为偶数
$$
\frac{1}{\sqrt[2]{(1+F)\times2^E}}=\frac{1}{(1+F)^{\frac{1}{2}}\times2^{\frac{E}{2}}}=\frac{2}{\sqrt[2]{1+F}}\times2^{-\frac{E}{2}-1}
$$
无论E的奇偶性如何，这里都写成了浮点数的计数法的形式。(注意小数部分一定是1.xxx的形式)
观察指数部分，可以发现：被开方数$$f$$的指数域，和$$f$$的平方根的倒数$$f^{'}$$的指数域，几乎是一半的差距，因此考虑直接对$$f$$的指数域进行一次线性变换（移位并加上一个偏移量），
来构造出$$f^{'}$$的指数域。
$$f$$的指数域：$$127+E$$
$$f^{'}$$的指数域：$$127-\frac{E+1}{2}$$或 $$127-\frac{E}{2}-1$$
假设偏移量为$$x$$
E为奇数时：
$$
x-\frac{127+E}{2} = 127 - \frac{E+1}{2}
$$
解得$$
x=190
$$
也就是说，190-原来的指数域/2,恰好是平方根倒数的指数域
E为偶数时：
$$
x-\frac{127+E}{2} = 127 - \frac{E}{2} - 1
$$
解得$$x=189$$
当E为偶数时，注意到指数域为奇数，即最后一位是1,经过右移后，减数的d22位为1,因此只要被减数的d22位为0,并且指数域为190,
那么fraction域作减法的时候，就会因为借位，使得指数域减1恰好变成189.
至此，我们已经可以构造出一个数：其指数域为190,并且它的d22位为0
我们回到代码中的magic number,其值为0x5f3759df，其二进制表示为 0 10111110 01101110101100111011111,发现满足上述条件。

再次注意到，当E为偶数时，做完减法以后，指数域的结果一定是$$127 - \frac{E}{2} - 1$$，但E为奇数时，由于被减数和减数的d22位都为0,如果被减数的d21-d0
比减数小，就会向高位借位，使得指数域相减的结果小1,这里会导致一定误差，但会被后续的迭代缩小。
接下来尝试构造剩余的位(d21-d0)。
假设将magic number看作是一个浮点数，其小数部分为M，由于其d22位为0,则$$ 0 \le M < 0.5 $$，因此在作$$ magic - (i >> 1) $$时，可以看作是定点小数的减法。
分情况讨论：
*** 1. E为奇数
此时指数域为偶数，即最后一位是0,经过右移后，d22位为0，因此小数部分的值为$$ \frac{F}{2}$$ ，最后一位如果是1,经过右移后会被舍弃掉，这个因为太小对误差影响不大。
假设$$ M \ge \frac{F}{2} $$ ，那就不需要向指数域借位，计算结果为：小数部分$$ M - \frac{F}{2} $$，且指数域部分符合预期，相对误差为$$ \Bigg|1-\frac{1+M-\frac{F}{2}}{\sqrt[2]{\frac{2}{1+F}}} \Bigg| $$，（注意前文对奇数的情况的分析）；
假设$$ M < \frac{F}{2} $$，此时需要向指数域借位，计算结果为：小数部分$$1+M-\frac{F}{2}$$，指数域比预期小1，因此在相对误差中需要补上这个差值：$$\Bigg|1-\frac{\frac{2+M-\frac{F}{2}}{2}}{\sqrt[2]{\frac{2}{1+F}}}\Bigg|$$，
*** 2. E为偶数
此时指数域为奇数，即最后一位为1,经过右移后，d22位为1,因此小数部分的值为$$\frac{1}{2} + \frac{F}{2}$$，前面说了，这种情况一定会产生借位，但指数域是符合预期的，
因此相对误差为：$$\Bigg|1-\frac{2+M-\frac{1}{2}-\frac{F}{2}}{\frac{2}{\sqrt[2]{1+F}}}\Bigg|$$。
到这一步，我们可以构造一个函数$$g(M)$$，它是从M到该M取值下的最大误差值（从前面的三个误差中求得的最大值）的映射。于是我们只要对这个$$g(M)$$作分析，
找到一个M使得$$g(M)$$的值最小，我们就得到了一个最优的magic number。

理论上说，这个区间的数是有限个的，通过穷举肯定能找到那个最优的解。但是计算量有点大。
因此我们考虑这样：在magic number的取值范围内$$ [0x5f000000, 0x5f3fffff]$$，均匀地取一些数，然后遍历常用浮点数计算$$g(M)$$，发现其曲线在区间内为一个波谷。
因此大胆假设其在区间内符合先递减后递增的连续函数。
定义start，end，初始为0x5F000000和0x5F3FFFFF，将区间[start, end]均匀分成32段，求33个数中g(M)最小的值，然后再将start和end定义为它的前一个和后一个。
反复迭代，直至区间收敛到一个比较小的范围，再对这个小区间进行穷举，最后求得一个最优解。
2003年普度大学数学家Chris Lomont找到了最优解0x5f375a86.至此，所有关于这个magic number的秘密就“逆向”到这里。

** 其内在的数学本质
如果要用一句话概括其本质，那么就是：浮点数的二进制表示近似于对数运算，只是带了一些偏移。
   \begin{center}
   \begin{equation}
y=\frac{1}{\sqrt[2]{x}}=x^{-\frac{1}{2}}
\Rightarrow \log_2 (y) = -\frac{1}{2}\log_2(x)
   \end{equation}
   \end{center}
   将y，x作为浮点数，带入到上面的式子中，得到
   \begin{center}
   \begin{equation}
\log_2((1+\frac{F_y}{2^{23}}) \times 2^{E_y-127}) = -\frac{1}{2} \times \log_2((1+\frac{F_x}{2^{23}}) \times 2^{E_x-127})
\Rightarrow E_y - 127 + \log_2(1+\frac{F_y}{2^{23}}) =-\frac{1}{2} \times (E_x - 127 + \log_2(1+\frac{F_x}{2^{23}}))
   \end{equation}
   \end{center}
   学过高数的你一定知道近似公式$$ \log_2(1+x) = x + \epsilon$$
   因此带入得到：
   \begin{center}
   \begin{equation}
   E_y -127 + \frac{F_y}{2^{23}} + \epsilon =-\frac{1}{2}(E_x-127) - \frac{1}{2}(\frac{F_x}{2^{23}}+\epsilon)
   \Rightarrow E_y \times 2^{23} + F_y = \frac{3}{2}(127-\epsilon)2^{23} - \frac{1}{2}(E_x\times2^{23}+F_x)
   \end{equation}
   \end{center}
   即左边为y的整数表达，右边为y的整数表达右移后，用一个数减，这个数如果忽略$$\epsilon$$，则刚好是一个指数域为190的数。
   因此，剩余的工作就是找到一个合适$$\epsilon$$的值（其实就是上一节对小数部分的分析，在本质上的体现），使得这部分估计的偏差最小即可。
   然后再进行一次或者两次牛顿迭代，抹除掉估计的偏差即可。
   
** 最后
现在有了快速计算平方根倒数的方法，用这个的结果乘以x本身，就得到了x的平方根。

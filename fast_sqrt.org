#+OPTIONS: tex:t
#+STARTUP: latexpreview
* 1.
** 迭代算法介绍
   初始的问题是：对于在区间$$ \left[ a, b \right] $$上连续且单调的函数$f(x)$，求方程$$f(x)=0$$的近似解.
   算法描述：
   任意取一个定义域内的值$$x_0$$，开始迭代。
   假设当前的近似解为$$x_i$$，则在点$$(x_i, f(x_i))$$上作$$f(x_i)$$的切线$$l$$，其与$$x$$轴的交点记为$$x_{i+1}$$，那么这是一个更优的近似解。
   切线的代数意义即为函数$$f(x)$$的导数，则可以得到这样的迭代式：
   \begin{center}
   \begin{equation}
   x_{i+1}=x_{i}-\frac{f(x_i)}{f^{'}(x_i)}
   \end{equation}
   \end{center}
   关于其收敛性的证明，请参考[[[[http://staff.science.uva.nl/c.dominik/]]]][这里]
** 计算平方根
   尝试求解$$\sqrt[2]{x}$$的值，其实等价于如下描述：
   设$$f(x)=x^2-n$$，求$$f(x)=0$$的近似解。
   按照前文的迭代式，可以得到：
   \begin{center}
   \begin{equation}
   x_{i+1}=x_{i}-\frac{x_{i}^{2}-n}{2x_i}
   \end{equation}
   \end{center}
   设定一个合适的精度，经过有限次迭代最终能得到一个近似解
* 2. 关于Quake3
** 背景
   在Quake3代码中，有这样一段求解平方根倒数的代码：
   #+BEGIN_SRC C
     float invSqrt(float x)
     {
	     float xhalf = 0.5 * x;
	     int i = *(int*)&x; // get bits for floating value
	     i = 0x5f3759df - (i >> 1); // gives initial guess
	     x = *(float*)&i; // convert bits back to float
	     x = x * (1.5 - xhalf * x * x); // Newton step
	     return x;
     }

   #+END_SRC
   粗看这个代码的逻辑，其实很简单，先取了一个初始值，然后进行了一次迭代。关键在于，仅仅经过一次迭代，
   如何保证结果的精度达到要求？原因在于初始值的选取，本来就已经十分接近解，再进行一次迭代来消除估值本身
   的误差。
** 从magic number出发对其合理性进行一个直观的感受
   
